% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rwTile.R
\name{writeTile}
\alias{writeTile}
\title{Compute and output a landscape}
\usage{
writeTile(inRdata, model, outFilename, layers = c("class"), threshold = 0,
  labels.all = NULL, ...)
}
\arguments{
\item{inRdata}{a raster stack (or brick) of the input data; can be loaded using \code{\link{readTile}}}

\item{model}{the model to use for predicting output values, often created using \code{\link{generateModels}}. The model class must have a
predict.model function.}

\item{outFilename}{the output filename}

\item{layers}{(optional) one or more of: "class" the chosen class; "prob" the probability of this class; "threshold" same as class where
probability is greater than or equal to threshold (below), 0 otherwise; "all" the probabilities for all classes (one layer per class
type)\ldots see Details.}

\item{threshold}{(optional) if the "threshold" layer is selected; this needs to be provided if a threshold output is selected: \eqn{0 < Th < 1}.}

\item{labels.all}{(optional) if 'all' is selected, specify labels for these layers; the default label is "prob.<class name>"}

\item{...}{variable(s) to pass to the model prediction function.}
}
\value{
a new raster.brick object pointing to \file{outFilename} containing the output landscape.
}
\description{
This function renders a landscape: this means taking in a set of raster layers (stack or brick) and a classification model, then pushing
all the pixels in the landscape through the model to get outputs (see details), and writing the result to a file. Since many raster.*
objects are too big to (reasonably) hold in memory the landscape is broken into blocks and processed in series.
}
\details{
There are several outputs that can be generated by this function. However, since the different packages implement in different ways, and
different limitations are imposed by different model types, the interface and output is not standardized. This function creates as
standard an interface as possible. Due to these inherent differences there are a few things to keep in mind:
\itemize{
  \item Nearest Neighbour algorithms, by their very nature, do not generate class probabilities; they output the nearest class. Hence, the
    option to output probabilities is disabled for the two primitive nearest-neighbour packages (fnn, class). However, the kknn package
    implements a kernel function that transforms nearest-neighbour distance to probability; hence, probability can be output for models
    generated using this package.
  \item Once we get neighbour output this will become another item ???
}

Given this, options for layers can be one or more of the following:
\itemize{
  \item \sQuote{\code{class}} will output the \sQuote{winning} class, that is, the class with the highest probability of occurrence.
  \item \sQuote{\code{prob}} the probability with which the \sQuote{winning} class won.
  \item \sQuote{\code{threshold}} if we don't trust the classes with \sQuote{winning} probabilities below a certain threshold, then this
  can be selected and classes that don't meet this requirement will be set to 0 in the output map.
  \item \sQuote{\code{all}} output all the probability for all the classes as a multi-layer map. Note that this can be an exceptionally
  large datafile--- as in the order of many gigabytes. Plan accordingly.
}
}
\section{Warning}{
 Runtimes may be long! On a 2015 iMac (Intel I5 quad-core 3.3 GHz, 8GB RAM, and SSD) it takes 12-15 hours to do a full
rendering of approximately 15k x 15k pixels (=225 Mpix). Also, output file sizes can be large(ish)---~2+ GB.
}
\examples{
\dontrun{
data ('Output/siteData.dat')

# Choose a model with specified groupings to load
type <- c('Full','Reduced')[2]                          # Select either full or reduced grouping
load (paste0('Output/',type,' Models/identity.dat'))
load (paste0('Output/',type,' Models/domSpecies.dat'))
load (paste0('Output/',type,' Models/domGroup.dat'))
load (paste0('Output/',type,' Models/MaxGranularity.dat'))
rm (type)

inRdata <- rData
# Choose a block and crop if desired
IB_1 <- maptools::readShapePoly('Input/Intensive Blocks/IB_1')
IB_2 <- maptools::readShapePoly('Input/Intensive Blocks/IB_2')
IB_3 <- maptools::readShapePoly('Input/Intensive Blocks/IB_3')
IB_4 <- maptools::readShapePoly('Input/Intensive Blocks/IB_4')
IB_5 <- maptools::readShapePoly('Input/Intensive Blocks/IB_5')
IB_6 <- maptools::readShapePoly('Input/Intensive Blocks/IB_6')
inRdata <- crop (inRdata,extent(IB_3))

# Output a tile--be sure the filename matches the parameters! There is no other check!!
writeTile (inRdata,
           modelRun[['gbm']],
           paste0(gisPath,'Renderings/identity_full_gbm_IB3.tif'),
           layers=c('class','prob'))
writeTiles (egTile,
            modelRun,
            'Renderings/identity_reduced_', gisPath, '_IB3.tif',
            layers=c('class'))
}
}
\seealso{
\code{\link{writeTiles}} for an automated way to render all models in a model block
}

