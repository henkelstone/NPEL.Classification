% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Models.R
\name{nnErrMap}
\alias{nnErrMap}
\title{Generate a map of the distance --- or error --- from a pixel to it's nearest neighbour.}
\usage{
nnErrMap(model, idLayer, rData, outFilename, kernel = NULL, weight = NULL)
}
\arguments{
\item{model}{the model used to generate the ID layer}

\item{idLayer}{the layer identifying which neighbour is the nearest of each pixel}

\item{rData}{a Raster* object with the 'other' raster data, that is all the data used to generate the model, and hence the distance from
this pixel to the nearest neighbour. Note: this must be the same extents and alignment as idLayer}

\item{outFilename}{the filename to which to write the data as it is generated.}

\item{kernel}{(optional) the function used to compute the distance, see details.}

\item{weight}{(optional) a function used to convert the distance to an error, see details.}
}
\value{
a raster* object representing distances/kernel values, or the error from \code{weight} function if specified.
}
\description{
Generate a map of the distance --- or error --- from a pixel to it's nearest neighbour.
}
\details{
One way to estimate the accuracy/confidence of a nearest neighbour map, is to compute the distance from a pixel to it's nearest
neighbour. It is important to understand that this 'distance' is not the spatial distance, i.e. the distance along the earths surface,
but rather the distance in the space in which this was the nearest neighbour, that is, the distance in the statistical space used. For
example, this might be the so-called \sQuote{Tasselled Cap} variables.

Since it is possible to measure distance through parameter space in non-Euclidean ways, the \code{kernal} parameter is provided. If this
argument is specified it should be a function in the form \code{f(a,b)} in which \code{a} and b are the vectors of data for this pixel
and it's nearest neighbour. If \code{kernel} is not provided it will default to the Euclidean distance, that is:
\deqn{ distance = \sqrt{\sum{(\vec{a}-\vec{b})^{2}}} }{distance = sqrt(sum( (a-b)^2 ))}

Distance, however, is not accuracy; in some cases though the two \emph{may} be linked. There could be a number of ways to determine this
relationship: linear modelling, piecewise linear modelling, logit models, etc. Once a model is developed, it is relatively simply to
predict accuracy using (other) measures of distance. Example code for doing this is included below.
}
\examples{
fx <- formula('siteID ~ brtns + grnns + wetns + dem + slp + asp + hsd')
nnData <- cbind(siteID=factor(1:nrow(siteData)), siteData)
models <- generateModels(nnData, suppModels[!suppModels \%in\% contModels], fx)

fNN <- paste0(dirname(tempfile()),'/Tmp_nn.tif')
egTile <- readTile(file.path(system.file("extdata", "egTile", package = "NPEL.Classification"),''),
                   layers=c('base','grnns','wetns','brtns','dem','slp','asp','hsd'))
egData <- writeTile (models[[1]], egTile, fNN, layers='class')
names (egData) <- 'siteID'

fEMap <- paste0(dirname(tempfile()),'/Tmp_nnEMap.tif')
nnEMap <- nnErrMap(models[[1]], egData, egTile, fEMap)
plot (nnEMap)

## Generate a distance/accuracy relationship
inputClass <- cbind(ecoType=siteData$ecoType, getData(models[[1]]))
predClass <- inputClass[getFitted(models[[1]]),]

dfIn <- cbind(inputClass[,-(1:2)], predClass[,-(1:2)])
nl <- ncol(dfIn)/2
kernel <- function(a,b){ sqrt(sum((a-b)^2)) }
df <- data.frame(dist=apply(dfIn,1, function(x){kernel(x[1:nl],x[(nl+1):(2*nl)])}),
                 correct=as.numeric(inputClass$ecoType == predClass$ecoType))
rm (dfIn,nl,kernel)

plot (df$dist,df$correct)
corrLm <- lm ('correct~dist', df)
summary (corrLm)                # No significant relationship in this case
abline (corrLm)

# Convert map to estimated accuracies afterwards; not meaningful with non-significant model!
Func <- function(x){ corrLm$coefficients[1] + x*corrLm$coefficients[2] }
plot(calc(nnEMap, Func))

unlink (fNN)
unlink (fEMap)
}
\seealso{
\code{\link{generateModels}}, and \code{\link{writeTile}} for more information on building models for imputation purposes.\cr
  \code{\link{impute}} for imputing other values from the map of nearest neighbours.
}

