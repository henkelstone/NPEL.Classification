% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rwTile.R
\name{impute}
\alias{impute}
\title{Impute data from a NN model}
\usage{
impute(inRdata, iData, outFilename, fx = NULL, x = NULL, y = NULL)
}
\arguments{
\item{inRdata}{a raster* object with the spatial data---typically a map of indices to the lookup table.}

\item{iData}{or imputation data; the lookup table that takes map values (e.g. \code{siteID}) and converts them to some other value, e.g.
a site characteristic such as cover, tree density, species composition, etc.}

\item{outFilename}{a file to hold the output resulting raster object.}

\item{fx}{(optional) a formula object specifying which column(s) in \code{iData} to output; if omitted, it will either be computed from x
and y, or assumed to be all columns in \code{iData}.}

\item{x}{(optional) a list of columns from \code{iData} to output; will be computed from fx if omitted.}

\item{y}{(optional) the pivot column that connects the model and the imputation data; if neither fx nor this is specified then it is
assumed to be the first column in \code{iData}.}
}
\value{
a raster.brick of the imputed data with as many layers as specified.
}
\description{
This function takes an input raster, that is, an image on a categorical variable, and generates an image (or images) of other data using
the input raster as a key or index variable. It is used to render maps of variables that are otherwise unsuitable using Nearest Neighbour
algorithms such as continuous variables.
}
\details{
It is perhaps easiest to explain the concept of imputation using an example: consider the case where the input raster represents the ID
of the nearest neighbour to that pixel; it is possible to impute environmental data by looking up each ID in the original dataset and
assigning that pixel the value (of the environmental variable) from that site. So if this pixel is nearest (in phase space) to site
No.153, then we can infer (impute) that it is also most likely to have similar environmental characteristics. This is significantly
better than generating a map of classes, then inferring values from the mean of the class as there is a huge amount of information lost
in mapping \code{N} sites to \code{k} classes.

This function is essentially similar to the SQL/database command JOIN; that is, it joins two groups of data using a common column, such
that every time a value \code{y} occurs in the first table, some or all of the addition columns in the second table \code{x} are appended
to the result. It is a glorified form of lookup table in which the vector of lookup values is all the pixels in the image.

Of course it is, in principle, possible to use this function to impute data that has been generated by some other type of model, however,
the other methods included in this package are all able to generate continuous variable output directly. Imputation has only the benefit
that it is possible to produce multiple output from a single rendering simply by imputing a different (suite of) variable(s).

Note: that the notation used for fx may not be intuitive: the \code{y} variable, usually the \sQuote{dependent} variable is used as the
pivot, which can intuitively seem like the dependent variable; in a like way the \code{x} variables, which are usually the
\sQuote{independent} variables, are output here. Use caution when specifying the formula; that this function expects only a single term
on the left and multiple terms on the right is a good clue as to which variables should be where.
}
\section{Note}{

An analysis that can be useful is to look at the frequency each site is used as a nearest neighbour. This is straightforward using the
output of the imputation map. Example code is given below.
}

\section{Warning}{

In an effort to streamline usage, this function will attempt to coerce non-numeric data into something that can be written using the
\link{raster} package.
To this end, if the data is found to be other than numeric, it is converted to numeric using the command
\code{as.numeric(factor(x))}, which, as has been observed before in this documentation returns the \emph{indices} of the factors. It
\emph{should} be possible to recover the values of the indices using this same typecast, however, there is a risk that there could be
some glitch or error, and a mismapping could result between factor indices and actual values.

\bold{It would be \emph{much} safer} to do your own typecast \bold{\emph{before}} passing the data to \code{impute}! 'Nuf said...
}
\examples{
fx <- formula('siteID ~ brtns + grnns + wetns + dem + slp + asp + hsd')
nnData <- cbind(siteID=factor(1:nrow(siteData)),siteData)
nnData <- get_all_vars(fx, nnData)
models <- generateModels(nnData, suppModels[!suppModels \%in\% contModels], fx)

fNN <- paste0(dirname(tempfile()),'/Tmp_nn.tif')
egData <- writeTile (models[[1]], egTile, fNN, layers='class')

fImpute <- paste0(dirname(tempfile()),'/Tmp_nnImpute.tif')
egImpute <- impute (egData, nnData, fImpute, formula('siteID~ecoType+bedrockD+parentMaterial'))
plot (egImpute)

## Frequency/sensitivity of nearest neighbour site dependency
freq <- table(getValues(egData))
plot (freq/sum(freq), ylab='freq')
hiFreq <- freq[freq > 100]
index <- as.integer(rownames(hiFreq))
print (cbind(freq=hiFreq, nnData[nnData$siteID \%in\% index,]))

unlink (fNN)
unlink (fImpute)
}
\seealso{
\code{\link{factor}} and \code{\link{ecoGroup}} for more information on the factor index gotcha.\cr
  \code{\link{generateModels}}, and \code{\link{writeTile}} for more information on building models for imputation purposes.\cr
  \code{\link{nnErrMap}} for outputting nearest neighbour distances, and generating accuracies from these.
}

